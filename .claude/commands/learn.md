# /learn - 提取可复用模式

分析当前会话并提取值得保存为技能的模式。

## 触发

在会话中解决非平凡问题后随时运行 `/learn`。

## 提取内容

寻找:

1. **错误解决模式**
   - 发生了什么错误?
   - 根本原因是什么?
   - 什么修复了它?
   - 这对类似错误可复用吗?

2. **调试技术**
   - 非显而易见的调试步骤
   - 有效的工具组合
   - 诊断模式

3. **解决方案**
   - 库的怪癖
   - API 限制
   - 版本特定的修复

4. **项目特定模式**
   - 发现的代码库约定
   - 做出的架构决策
   - 集成模式

## 输出格式

在 `~/.claude/skills/learned/[pattern-name].md` 创建技能文件:

```markdown
# [描述性模式名称]

**提取时间:** [日期]
**上下文:** [适用场景的简要描述]

## 问题
[这解决什么问题 - 要具体]

## 解决方案
[模式/技术/解决方案]

## 示例
[如适用的代码示例]

## 何时使用
[触发条件 - 什么应该激活此技能]
```

## 流程

1. 审查会话中可提取的模式
2. 识别最有价值/可复用的见解
3. 起草技能文件
4. 请用户确认后保存
5. 保存到 `~/.claude/skills/learned/`

## 示例

### PyQt6 信号连接问题

```markdown
# PyQt6 信号在子类中的正确连接

**提取时间:** 2026-02-04
**上下文:** PyQt6 信号槽机制

## 问题
在 QThread 子类中，信号连接在 __init__ 中失败，
抛出 "signal only works for objects of type" 错误。

## 解决方案
确保在连接信号之前调用 super().__init__()，
且信号定义在类级别而非实例级别。

## 示例
```python
class Worker(QThread):
    finished = pyqtSignal(bool)  # 类级别定义

    def __init__(self):
        super().__init__()  # 必须先调用
        self.finished.connect(self.on_finished)  # 然后连接
```

## 何时使用
当看到 PyQt6 信号连接错误或
"signal only works for objects" 类型错误时。
```

## 注意事项

- 不要提取平凡的修复 (拼写错误、简单语法错误)
- 不要提取一次性问题 (特定 API 中断等)
- 聚焦于能在未来会话中节省时间的模式
- 保持技能聚焦 - 每个技能一个模式
